# Java内存回收机制详解

>我们在写Java程序时不需要写释放资源的逻辑，垃圾收集的工作是完全交予虚拟机来处理的。这样虽然减轻了程序员的负担，但是相应的，软件系统也受到了同等的威胁。比如在任务结束或失败时，如果没有及时的释放资源或释放不完全，就会造成内存泄漏，严重时会造成内存溢出。因此程序员虽然不需要手动释放资源，但必须知道内存回收的内部细节，这样就在发生内存泄漏时才能够准确的找出问题的所在。

### 可达性分析算法

Java虚拟机是使用的可达性分析算法来判断对象是否可以被回收，虚拟机在对象引用链上，从GC Roots对象向下搜索，当一个对象没有任何一个GC Roots对象可达时，就代表对象是不可用的，可以被回收。

Java中可作为GC Roots的对象有

1. 虚拟机栈中引用的对象（代表有正在或将要调用的方法引用该对象）
2. 方法区中静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中JNI（native方法）引用的对象 

### 何为引用

如果reference类型数据中存储的数值代表着另一块内存的起始地址，那么就称为这块内存代表着一个引用。

Java中存在四种引用，引用强度依次变弱：

1. **强引用(Strong Reference)：**没有对应的类，是Java中普遍存在的引用，如Object o=new Object()就是一种强引用，只要和GC Roots直接或间接存在强引用，虚拟机便永远不会回收这些对象。
2. **软引用(Soft Reference)：**对应类为SoftReference，软可到达对象的所有软引用都要保证在虚拟机抛出 OutOfMemoryError之前已经被清除，此类的直接实例可用于实现简单缓存；该类或其派生的子类还可用于更大型的数据结构，以实现更复杂的缓存。只要软引用的指示对象是强可到达对象，即正在实际使用的对象，就不会清除软引用。
3. **弱引用(Weak Reference)：**对应类为WeakReference，它用来标记非必需的对象，被它标记的对象只能生存到下一次垃圾收集之前。
4. **虚引用(Weak Reference)：**对应类为PhantomReference，一个对象是否被虚引用引用不会对对象的生命周期造成任何影响，它的作用只是会在回收对象时收到一个通知。

### Stop-The-World
由于对象的引用关系是处于不断的变化中的，这样可达性分析就有可能不准确，那么就必须让分析工作在一个确保一致性的内存快照上执行，也就是在分析时要让整个系统停止在某一个时间点上，这样就会导致除GC线程以外的所有线程暂时停止。这个过程被称为“Stop-The-World”。

### OopMap与安全点

*此处参考了[<https://rednaxelafx.iteye.com/blog/1044951>](<https://rednaxelafx.iteye.com/blog/1044951>)*

在类加载完毕后，对象会在类型信息中生成自己OopMap，它记录了该类型的对象在什么偏移量上是什么类型的数据，便可以一步步分析该对象的引用链。所以从对象开始向外的扫描可以是准确的（准确式GC的实现）。

每个被JIT编译过后的方法也会在**一些特定的位置**记录下OopMap，记录了执行到该方法的某条指令的时候，栈上和寄存器里哪些位置是引用。这样GC在扫描栈的时候就会查询这些OopMap就知道哪里是引用了。这些特定的位置主要在： 

1. 循环的末尾 

2. 方法临返回前 / 调用方法的call指令后 

3. 可能抛异常的位置 

这种位置被称为**“安全点”（safepoint）**。之所以要选择一些特定的位置来记录OopMap，是因为如果对每条指令（的位置）都记录OopMap的话，这些记录就会比较大，那么空间开销会显得不值得。选用一些比较关键的点来记录就能有效的缩小需要记录的数据量，但仍然能达到区分引用的目的。因为这样，HotSpot中GC不是在任意位置都可以进入，而只能在safepoint处进入。 

### 老年代和新生代

**新生代（Young）：**占据了1/3的堆空间，包含两个Survivor区和Eden区，默认的，Eden：Survivor：Survivor=8:1:1，两个Survivor区总有一块是空闲的，在下面讲复制算法时会解释。

**老年代（Old）：**占据了2/3的堆空间。

### Minor GC与Full GC

**Minor GC**是指在新生代发生的GC，由于大部分Java对象朝生夕灭，所以Minor GC非常频繁，回收速度也较快。

**Full GC**也称为Major GC，是指发生在老年代的GC，每次Full GC往往会伴随着至少一次的Minor GC，Full GC速度很慢，比Minor GC慢10倍以上，所以我们应尽量避免Full GC。

### 对象的年龄与对象的分配

1. **对象优先分配在Eden区**，当Eden区没有足够的空间供分配时，系统会发起一次Minor GC
2. **大对象直接进入老年代**，何为大对象？需要连续内存空间的对象，如很长的字符串或数组。我们应避免让程序出现用完即丢的短命大对象，因为它会导致内存经常不足，而频频触发内存回收。
3. **长期存活的对象进入老年代**，每一个对象都有一个年龄计数器（Age），经过第一次Minor GC没有被回收时会被移入Survivor区，年龄设定为1，以后在Survivor区每次经过Minor GC没有被回收年龄便加1，直到年龄到达一定的程序（ 默认为15）便晋升为老年代。
4. **动态对象年龄判定**，如果Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象便被移入老年代，无需到达规定的晋升年龄。
5. **空间分配担保，**发生Minor GC之前，虚拟机会检查老年代（Old）的最大连续可用空间，判断是否大于所有新生代（Young）对象的空间，如果成立，那么这次Minor GC便是安全的；如果不成立，虚拟机便会查看HandlePromotionFailure参数判断是否这次GC是否允许冒险。如果允许，那么虚拟机会判断历次经过Minor GC时新生代晋升至老年代的对象平均大小是否小于老年代的最大连续空间，如果大于，那么便可以尝试进行Minor GC，尽管它是有风险的,如果由于存活对象突增而导致失败了，那么就会触发Full GC，那么；如果不允许冒险，那么这次Minor GC就会直接改为Full GC。

### 垃圾回收的常用算法

1. #### **引用计数法（Java虚拟机并没有采用这种方式）**

   每使用一个对象时就给该对象的引用计数器+1，引用失效时就给引用计数器-1，当对象的引用数量为0时，就说明该对象未被使用

   **缺点：**

   不能处理循环引用问题，两个对象相互引用，当两个对象都使用完毕时，由于两个垃圾对象都持有对对方的引用，导致两个对象都无法被回收。

2. #### **标记-清除法** 

   从GC根节点（GC Roots）开始，通过引用链标记所有引用该节点及其子节点的对象，标记完毕后，回收未被标记的对象。

   **缺点：**

   1. 需要回收的对象位置随机，回收后会造成大量的内存碎片，在堆空间的分配过程中，大对象的内存分配效率下降。
   2. 标记和清除的效率都不高。

3. #### **复制算法**

   将现有的内存空间分为两快，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。

   **新生代使用的GC算法就是复制算法。**

   由实际检测证明两块内存不需要1:1，因为新生代的98%对象都是“朝生夕死”的，所以虚拟机一般都采用两块Survivor区和一块Eden区，比例为8:1:1。具体操作为：将Eden和Survivor的存活对象保存到另一个Survivor区内，清除Eden和前一个Survivor区的所有对象。

4. #### **标记-整理算法（也称作标记-压缩算法）**

   标记-整理算法其实是标记-清除算法的升级，它通过可达性分析并标记可回收对象以后，并不直接进行回收，使存活的对象向一端移动，然后清除掉端边界以外的内存，这样可以克服标记-清除算法的内存碎片问题。

   **老年使用的GC算法就是标记-整理算法**

   为什么在老年代不和新生代一样有两个Survivor区？因为老年代使用的方法便是标记-整理算法，因为老年代中对象存活率较高，需要复制的对象较多，要使用复制算法就会浪费50%的空间。而使用标记-整理算法的话就可以省下这一块空间了。

5. #### **分代收集算法**

   根据各种年龄代的特征不同而衍生出的算法。

   比如：

   新生代每次GC会有大量对象死去，只有少部分被留下，所以采用复制算法。
   老年代存活时间长，且没有额外的空间对它进行分配担保，所以采用“标记-清除”或“标记-整理”算法。

### Java默认虚拟机HotSpot的垃圾收集器

![](http://www.theaze.cn/wp-content/uploads/2019/04/collectors.jpg)

上图代表了几种用于老年代和新生代的几种收集器，有连线的收集器代表可以搭配使用，每一种收集器都有其优点和缺点。

#### Serial收集器

Serial收集器是最基本的收集器，它在进行垃圾回收时会停止除了GC线程以外的全部其他线程，也就是前面说的“Stop The World”。

Serial/Serial Old可以搭配使用，在新生代使用Serial收集器，使用的算法是复制算法，在老年代是用Serial Old收集器，使用的算法时“标记-整理”算法。

优点：

​	简单高效，在单核CPU上由于没有线程交互的开销，垃圾收集效率较高。

#### ParNew收集器

Serial收集器的多线程版本，也可以和Serial Old搭配使用，也使用了复制算法。实际上它和Serial收集器共用了许多代码。

优点：

​	虽然在单核CPU上没有Serial收集器效率高，但现代服务器CPU核心数都是动辄几十核，在这种环境下ParNew收集器就比Serial收集器优秀。

#### Parallel Scavenge收集器

和ParNew收集器类似，同样是新生代的收集器同样是用的复制算法，但是它有独特的关注点：吞吐量。吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)。

优点：

​	它有自适应调节策略，可以通过监视当前的运行数据，自动调整相关参数以提供最合适的停顿时间或吞吐量，可以将系统吞吐量维持在一个预定义的百分比值内。

#### Serial Old收集器

单GC线程的老年代的收集器，利用了“标记-整理”算法。

#### ParNew Old收集器

多GC线程的老年代的收集器，利用了“标记-整理”算法，是Parallel Scavenge收集器的老年代版本。

#### CMS收集器

CMS(Concurrent Mark Sweep)收集器利用了“标记-清除”算法，它的关注点在于更短的停顿时间。整个过程共分为4个步骤：

1. 初始标记
2. 并发标记
3. 重新标记
4. 并发清除

初始标记以及重新标记时需要“Stop The World”。

优点：

​	垃圾收集速度快，并发收集，低停顿。

缺点：

1. 对CPU资源敏感，当CPU数量较少时，会造成用户线程卡顿。
2. 无法处理“浮动垃圾”，这是由于在并发清除时程序仍在运行，这样的垃圾出现在垃圾标记之后，CMS自然就无法处理它们。

3. 产生内存碎片。由于基于“标记-清除”算法，在垃圾收集时自然会产生内存碎片。

#### G1收集器

G1收集器将整个内存区域划分成多个大小相等的Region，虽然还保留着新生代和老年代的概念，但是不再是物理隔离的，他们都是一部分不需要连续的Region集合。

G1收集器的4个步骤：

1. 初始标记
2. 并发标记
3. 最终标记
4. 筛选回收

G1收集器的特点：

1. 并行与并发：充分利用多CPU，多核环境下的硬件优势。
2. 分代收集：保留了分代的概念，但不需要其他收集器的配合，可以独自管理整个GC堆。
3. 空间整合：从整体基于“标记-整理”，从局部基于“复制”，不会产生内存碎片。
4. 可预测的停顿：G1收集器的关注点和CMS一样，也是停顿速度，但是不同的是，G1可以通过监视系统状态建立一个可预测停顿时间的模型。