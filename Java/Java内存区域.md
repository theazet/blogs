# Java内存区域

![Java内存区域](<https://www.theaze.cn/wp-content/uploads/2019/02/%E6%9C%AA%E6%A0%87%E9%A2%98-1.png>)

Java虚拟机在运行时会把内存分为若干不同的数据区域，他们都有自己不同的职责。

**何为线程隔离与线程共享？**

线程隔离是每个线程拥有自己的数据区域，互不影响独立存储，“随线程而生，随线程而灭”。而线程共享则相反，每个线程使用同一块数据区域。

### Java内存区域

#### 程序计数器

线程隔离区域，一块较小的内存空间，可以看做当前线程的行号指示器，它当中记录的是在执行的虚拟机字节码指令的地址。

#### Java虚拟机栈

线程隔离区域，它描述的是Java方法执行的内存模型， 每个方法在执行时都会创建一个栈帧，用于存储变量表、操作数栈、动态链接、方法出口等信息，方法创建时入栈，方法退出时出栈。

这块内存就是常说的栈内存(Stack)，这里规定了两个异常状况，当线程请求的栈深度大于虚拟机栈允许深度，就会抛出StackOverflowError(SOF)异常，当虚拟机动态扩展时请求不到足够的内存，就会抛出OutOfMemory(OOM)异常。

#### 本地方法栈

线程隔离区域，和Java虚拟机栈类似，不同的是本地方法栈只为Native方法服务。

#### Java堆

线程共享区域，Java内存中最大的一块区，几乎所有的对象实例和数组都在这里分配，所以这里也是GC操作的主要区域。虚拟机允许Java堆处于不连续的物理内存上，只要在逻辑上连续即可。在空间分配，它是可以固定大小或者扩展的，如果在堆上没有足够的内存可以分配也无法继续扩展时，也会抛出OOM（OutOfMemory）错误。

#### 方法区

线程共享区域，用于储存已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，在这个数据区域很少进行垃圾收集，回收的目标一般是针对常量池的回收或对类型的卸载。当需要的内存无法满足时，会抛出OOM异常。

#### 运行时常量池

它是方法区的一部分，所以它也是线程共享的，用于存储编译期生成的各种符号字面量和符号引用。运行时常量池具备动态性，在程序运行时也可以能有新的常量加入池中，此特性被利用较多的是String的intern()方法

#### 直接内存

并不属于Java内存区域，但它也被经常的使用且有可能出现OOM，我们在使用NIO时会利用Native函数库直接分配堆外内存。放各个内存区域总和大于机器物理内存地址时，会导致动态内存扩展时出现OOM。

### 对象创建过程

- 虚拟机遇到new指令
- 检查这个指令的参数能否在常量池定位到一个类的符号引用，并检查这个类是否被加载、解析和初始化过。
- 如果没有则执行类加载过程
- 为对象在堆上划分出一个对象需要的空间分配给对象
- 将分配的内存空间初始化为零值(除了对象头)
- 虚拟机设置对象头
- 此时在虚拟机的视角上新的对象产生，虚拟机开始执行<init>方法执行对象初始化

###  对象内存布局

对象在内存中的3块储存区域

1. 对象头
2. 实例数据
3. 对齐填充

#### 对象头

对象头中包含两部分信息：运行时数据与类型指针

**运行时数据：**

如hashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，官方称其为“Mark Word”

**类型指针：**

指向它的类元数据的指针，虚拟机用它来确定它是哪个类的实例。

#### 实例数据

对象存储的真正有效信息。

#### 对齐填充

仅仅是因为Java对象大小必须是8字节的整数倍，需要通过对齐填充来补全。