# Java并发编程基础

### JMM模型

#### 处理器、高速缓存、主内存关系

![](http://www.theaze.cn/wp-content/uploads/2019/04/v2-1a021d2833b7a537dcdfdf0025f52a6c_r.jpg)

**缓存一致性问题：**每一个处理器都自己的高速缓存，而且它们有共享同一个主内存，如果这几个处理器的运算任务都涉及到同一块内存，就可能会导致各个高速缓存中的内容不一致，这样就会出现缓存一致性的问题，为解决这一问题，每个处理器在访问缓存时都会遵循缓存一致性协议，比如MSI、MESI、MOSI...

#### JMM
![](http://www.theaze.cn/wp-content/uploads/2019/04/v2-af520d543f0f4f205f822ec3b151ad46_r.jpg)



### volatile的使用


synchronized与volatile在Java并发编程中都扮演者重要的角色，volatile是一种轻量的synchronized，利用得当可以实现高效率的并发。

**volatile可以保证变量有以下特点：**

1. **可见性**：确保所有的线程看到变量的值是一致的
2. **禁止指令的重排序**

**volatile是怎样保证变量可见性的？**

JMM规定，每个线程都有自己的工作内存，线程的工作内存中保存了该线程使用到的变量的主内存的副本，线程所有的赋值、读取等操作都必须在工作内存中进行，而不能直接读写主内存中的变量。而如果被volatile修饰的话，**所有的读取操作之前都必须先清除工作内存的值，再从主内存获取最新值**(与进入synchronize代码块语义相同)；**所有的赋值操作之后都必须将值刷新到主内存**(与退出synchronize代码块语义相同)，这样就保证了内存的一致性。

volatile**不能保证原子性**，在不符合以下两个规则的场景下，我们仍要通过加锁来保证原子性。

1. 运算结果不依赖变量的当前值，能够确保只有单一线程修改变量的值。
2. 变量不需要和其他的状态变量共同参与不变约束。

```java
//通过可见性实现一个volatile变量控制并发的例子
volatile boolean shutdown;
public void shutdown(){
    shutdown=true;
}
public void doWork(){
    while(!shutdown){
        //执行逻辑
    }
}
```

```java
/**
用禁止指令重排序实现DCL双重检查锁定（double checked locking）的单例模式,
避免锁整个方法导致的性能损失，但也导致了线程不安全问题，必须要加volatile关键词
**/
public class Singleton{
    private volatile static Singleton instance;
    public static Singleton getInstance(){
        if(instance==null){
            synchronized(Singleton.class){
                if(instance==null){
                    instacne==new Singleton();
                }
            }
        }
        return instance;
    }
}
```

`instacne==new Singleton();`此操作包含三个过程

1. 为instance分配内存
2. 对Singleton()方法进行初始化
3. 将对象instance指向分配的内存上

如果变量没有被volatile所修饰，那么就有可能由于指令重排序导致执行顺序为2->3->1，当整个过程还没有结束时，如果一个新的线程加入了，此时instance虽然不为null，但它指向的内存地址确是空的，那么就会出现错误。

### 重量级锁synchronize及锁优化

> 每一个对象都拥有一个监视器锁(monitor)，线程执行**monitorenter**指令时会尝试获取监视器锁(monitor)的所有权，将会执行以下过程：
>
> 1. 如果monitor的进入数为0，则线程进入monitor，然后进入数置为1，该线程成为monitor的所有者。
> 2. 如果该线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1(可重入锁)。
> 3. 如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，则再重新尝试monitor的所有权。
>
> 执行**monitorexit**指令时会放弃监视器锁(monitor)的所有权，能够执行monitorexit的线程只有monitor的所有者，将会执行以下过程
>
> 1. 指令执行时，monitor进入数减1，如果进入数变为了0，那么线程退出monitor，不再是monitor的所有者，其他被monitor阻塞的线程可以尝试获取monitor的所有权。

synchronize会在同步代码块开始的位置插入monitorenter指令，在同步块结束处和异常出插入monitorexit指令。JVM会保证每个monitorenter都有相应的monitorexit与之关联。

由于Java中的线程和操作系统的原生线程是一一对应的，所以当阻塞一个线程时，需要从用户态切换至内核态执行阻塞操作，这是很耗时的操作，synchronize就会导致上下文切换。

**Java中的每一个对象都可以作为锁，synchronize具体表现为以下三种形式**

- 对于普通同步方法，锁的是当前调用该方法的实例对象
- 对于静态同步方法，锁的是当前类的Class对象
- 对于同步方法块，锁是Synchronize括号里配置的对象。

#### 锁优化

- **自旋锁与适应性自旋：**

  由于线程调度需要不小的开销，所以当线程请求锁失败时，可以先不让该线程失去处理器的执行时间，让线程执行一断时间的忙循环(自旋)，尝试获取锁，这项技术就叫做**自旋锁**。
  
- **逃逸分析与锁消除：**
  
  当一个对象在方法中被定义后，它如果能够被外部方法引用，作为参数传递到其他方法中，称为方法逃逸。
  
  如果能证明一个对象不会逃逸到方法或线程之外，也就是别的方法和线程无法访问到这个对象，就能为该对象做一些如下的优化。
  
  1. 栈上分配：一般来说，虚拟机会在堆上分配对象内存，但是回收对象需要耗费时间，如果能在栈上分配对象内存，就能让对象随着方法的结束而自行销毁，缓解垃圾回收的压力。
  2. 同步消除：如果判断一个对象不会逃逸，那就可以判断它不会被其他线程访问，不会产生竞争，那么就可以将同步操作消除，这称为**锁消除**。
  3. 标量替换：一个数据不能再分解成更小的数据来表示时，称为**标量**；而一个数据如果能继续分解就称为**聚合量**，Java对象就是一个典型的聚合量。如果逃逸分析证明一个对象不会被外部对象访问，并且这个对象可以被拆散的话，那么程序真正执行的时候可能就不会创建这个对象，而是改为创建这个方法用到的成员变量来代替。
  
- **锁粗化：**

  一串连续(如循环)操作对同一对象进行加锁，可以扩展加锁的范围，从而只对对象加锁一次。

- **轻量级锁：**

  对象头的Mark Word中有2bit用于存储锁标志位，轻量锁的使用过程是这样的：

  1. 如果同步对象没有被锁定，JVM首先在当前线程的栈帧中建立一个锁记录(Displaced Mard Word)的空间，用于存储对象目前Mark Word的拷贝，然后通过CAS操作更新指向锁记录的指针。
  2. 如果成功了，线程获得锁；如果失败了，说明其他线程竞争锁，那便尝试自旋来获得锁。
  3. 轻量级锁解锁时，会使用原子的CAS操作将锁记录替换会对象头，如果成功了，说明竞争没有发生；如果失败了，说明此锁存在竞争，那么锁就会膨胀为重量级锁。
  
- **偏向锁：**

  1. 当一个线程访问同步块时，会使用CAS在对象头和栈帧中的锁记录存储偏向锁的线程ID，以后该线程进入该同步块时，不需要任何的同步操作。
  2. 如果其他的线程请求获取锁，那么偏向模式宣告结束，以后会根据对象目前是否处于被锁定状态，撤销偏向后恢复到未锁定状态或轻量锁状态。

### Java的主流锁

![](http://www.theaze.cn/wp-content/uploads/2019/05/7f749fc8.png)

#### 悲观锁

悲观的假设共享资源一定会出现竞争，每次访问时都会去做锁相关的同步措施。

#### 乐观锁

悲观的假设共享资源不会出现竞争，当需要使用共享资源时，先进行使用，如果没有产生冲突，那么操作就成功了；如果产生了冲突，再采取相应的补救措施，最常见的措施就是自旋，而不是将线程挂起，这种措施成为**非阻塞同步**。

#### 循环CAS操作实现原子操作

CAS全称为Compare and Swap，它需要两个值，一个旧值和一个新值，在操作期间看旧值有没有变化，如果没有变化再更新新值，如果发生了变化就不更新。循环CAS就是当更新失败时让线程进入一个忙等待，不断尝试更新直至成功。